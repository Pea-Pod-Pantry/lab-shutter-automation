substitutions:
  name: "inside-shutter"
  friendly_name: "Inside Shutter Controller"

esphome:
  name: ${name}
  on_boot:
    - priority: 600
      then:
        - lambda: |-
            if (id(master_pin) == 0) {
              // use esp_random() for hardware RNG, modulus for 6 digits
              id(master_pin) = (esp_random() % 900000) + 100000;
              ESP_LOGI("setup", "GENERATED NEW MASTER PIN: %d", id(master_pin));
            } else {
              ESP_LOGI("setup", "Master PIN already set.");
            }
    - priority: -10
      then:
        - lambda: |-
             // Force update the display sensor so it shows up on the Web UI immediately
             if (id(master_pin) != 0) {
               id(master_pin_display).publish_state(to_string(id(master_pin)));
             }
external_components:
  - source:
      type: local
      path: components

uart_reader:
  uart_id: uart_bus
  text_sensor_id: uart_message

esp32:
  board: wt32-eth01
  framework:
    type: arduino


wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:

ota:
  - platform: esphome

logger:
  baud_rate: 115200

uart:
  id: uart_bus
  tx_pin: GPIO17
  rx_pin: GPIO5
  baud_rate: 9600
  debug:
    direction: BOTH
    dummy_receiver: false

web_server:
  port: 80

# Session Management
globals:
  - id: session_active
    type: bool
    initial_value: 'false'
  - id: master_pin
    type: int
    restore_value: yes
    initial_value: '0' # 0 indicates not set/needs generation
  - id: user_pin
    type: std::string
    restore_value: yes
    initial_value: '"1234"' # Default user PIN
  - id: auth_tags
    type: std::string
    restore_value: yes
    initial_value: '""' # Comma separated list of tags
  - id: admin_mode
    type: bool
    initial_value: 'false'
  - id: registration_mode
    type: bool
    initial_value: 'false'



script:
  - id: start_session
    mode: RESTART
    then:
      - globals.set:
          id: session_active
          value: 'true'
      - logger.log: "Session STARTED - Access Granted"
      # - output.turn_on: buzzer_pwm (If we had one)
      - delay: 60s
      - globals.set:
          id: session_active
          value: 'false'
      - logger.log: "Session ENDED"

text:
  - platform: template
    name: "Admin PIN Input"
    id: admin_pin_input
    optimistic: true
    on_value:
      then:
        - lambda: |-
             int input_pin = atoi(x.c_str());
             if (input_pin == id(master_pin)) {
               id(admin_mode) = true;
               ESP_LOGI("admin", "Admin Mode UNLOCKED via Web");
             } else {
               ESP_LOGW("admin", "Invalid Master PIN attempt");
             }

  - platform: template
    name: "Set User PIN"
    id: set_user_pin_input
    optimistic: true
    min_length: 4
    max_length: 4
    on_value:
      then:
        - lambda: |-
            if (id(admin_mode)) {
              id(user_pin) = x;
              ESP_LOGI("admin", "User PIN updated to: %s", x.c_str());
            } else {
              ESP_LOGW("admin", "Cannot set User PIN: Admin not unlocked");
            }

button:
  - platform: template
    name: "Unlock Admin Mode"
    id: unlock_admin_btn
    on_press:
      - lambda: |-
          // This button is just a trigger, the text input logic handles the check.
          // Or we could move the check here if we want a "Submit" style.
          // For now the text input handler does it immediately.
          ESP_LOGI("admin", "Admin Unlock Requested (check Input field)");

  - platform: template
    name: "Toggle Card Registration"
    id: toggle_registration_btn
    on_press:
      - lambda: |-
          if (id(admin_mode)) {
            id(registration_mode) = !id(registration_mode);
            if (id(registration_mode)) {
               ESP_LOGI("admin", "Registration Mode ENABLED");
            } else {
               ESP_LOGI("admin", "Registration Mode DISABLED");
            }
          } else {
            ESP_LOGW("admin", "Cannot toggle registration: Admin not unlocked");
          }

  - platform: template
    name: "Clear All Cards"
    id: clear_cards_btn
    on_press:
      - lambda: |-
          if (id(admin_mode)) {
            id(auth_tags) = "";
            ESP_LOGI("admin", "All cards CLEARED");
          } else {
             ESP_LOGW("admin", "Cannot clear cards: Admin not unlocked");
          }

text_sensor:
  - platform: template
    name: "Master PIN Display"
    id: master_pin_display
    # Updated via on_boot to be static and immediate


  - platform: template
    name: "Registered Tags"
    id: registered_tags_display
    update_interval: 60s
    lambda: |-
      return id(auth_tags);

  - platform: template
    name: "UART Message"
    id: uart_message
    on_value:
      then:
        - lambda: |-
            ESP_LOGD("uart_logic", "Received RAW: %s", x.c_str());
            std::string msg = x;
            if (msg.find("PIN:") == 0) {
              std::string pin = msg.substr(4);
              if (pin == id(user_pin)) {
                 id(start_session).execute();
              } else {
                 ESP_LOGW("auth", "Invalid PIN: %s", pin.c_str());
              }
            } else if (msg.find("TAG:") == 0) {
              std::string tag = msg.substr(4);
              
              if (id(registration_mode)) {
                 // Register the tag
                 if (id(auth_tags).find(tag) == std::string::npos) {
                     if (id(auth_tags).length() > 0) {
                        id(auth_tags) += ",";
                     }
                     id(auth_tags) += tag;
                     ESP_LOGI("auth", "New TAG Registered: %s", tag.c_str());
                 } else {
                     ESP_LOGI("auth", "TAG already registered: %s", tag.c_str());
                 }
              } else {
                 // Authenticate
                 if (id(auth_tags).find(tag) != std::string::npos) {
                    id(start_session).execute();
                 } else {
                    ESP_LOGW("auth", "Unknown TAG: %s", tag.c_str());
                 }
              }

            } else if (msg.find("CMD:") == 0) {
              std::string cmd = msg.substr(4);
              if (cmd == "STOP") {
                id(shutter_cover).make_call().set_command_stop().perform();
                ESP_LOGI("auth", "Emergency STOP triggered");
              } else if (id(session_active)) {
                if (cmd == "UP") {
                  id(shutter_cover).make_call().set_command_open().perform();
                } else if (cmd == "DOWN") {
                  id(shutter_cover).make_call().set_command_close().perform();
                }
              } else {
                ESP_LOGW("auth", "Ignored: Session inactive");
              }
            }

# Motor Control Relays


cover:
  - platform: template
    name: "Shutter Control"
    id: shutter_cover
    open_action:
      - switch.turn_on: motor_up_relay
    close_action:
      - switch.turn_on: motor_down_relay
    stop_action:
      - switch.turn_on: motor_stop_relay
    optimistic: true

switch:
  - platform: gpio
    pin: GPIO4
    name: "Motor UP Relay"
    id: motor_up_relay
    interlock: [motor_down_relay, motor_stop_relay]
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 250ms
      - switch.turn_off: motor_up_relay
  
  - platform: gpio
    pin: GPIO2 # Often Onboard LED
    name: "Motor DOWN Relay"
    id: motor_down_relay
    interlock: [motor_up_relay, motor_stop_relay]
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 250ms
      - switch.turn_off: motor_down_relay

  - platform: gpio
    pin: GPIO32
    name: "Motor STOP Relay"
    id: motor_stop_relay
    interlock: [motor_up_relay, motor_down_relay]
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 250ms
      - switch.turn_off: motor_stop_relay

# Manual Control Buttons
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO15
      mode: INPUT_PULLUP
      inverted: true
    name: "Manual UP Button"
    id: manual_up_button
    on_press:
      - logger.log: "Manual UP Pressed"
      - cover.open: shutter_cover

  - platform: gpio
    pin:
      number: GPIO14
      mode: INPUT_PULLUP
      inverted: true
    name: "Manual DOWN Button"
    id: manual_down_button
    on_press:
      - logger.log: "Manual DOWN Pressed"
      - cover.close: shutter_cover

  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    name: "Manual STOP Button"
    id: manual_stop_button
    on_press:
      - logger.log: "Manual STOP Pressed"
      - cover.stop: shutter_cover


